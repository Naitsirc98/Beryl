#version 450 core

struct DrawCommand {
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
};

struct BoundingSphere {
    float centerX;
    float centerY;
    float centerZ;
    float radius;
};

// TODO: need camera matrices

layout(local_size_x = 1) in;

layout(std430, binding = 0) readonly buffer MeshCommandBuffer {
    DrawCommand[] meshCommands;
};

layout(std430, binding = 1) writeonly buffer CommandBuffer {
    DrawCommand[] instanceCommands;
};

layout(std430, binding = 2) readonly buffer BoundingSpheres {
    BoundingSphere boundingSpheres[];
};

layout(std430, binding = 3) readonly buffer Matrices {
    mat4 modelMatrices[];
};

layout(std430, binding = 4) readonly buffer MeshIDs {
    int meshIDs[];
};

layout(std140, binding = 5) uniform Frustum {
    mat4 projectionViewMatrix;
    vec4 planes[6];
} u_Frustum;

bool isVisible(mat4 modelMatrix, BoundingSphere boundingSphere);

void main() {

    const uint index = gl_GlobalInvocationID.x;

    const int meshID = meshIDs[index];

    if(isVisible(modelMatrices[index], boundingSpheres[meshID])) {

        DrawCommand meshCommand = meshCommands[meshID];

        DrawCommand command = meshCommand;

        command.instanceCount = 1;
        command.baseInstance = index;

        instanceCommands[index] = command;
    }
}

float getScale(mat4 m) {

    vec3 scale;

    scale.x = sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1] + m[0][2] * m[0][2]);
    scale.y = sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1] + m[1][2] * m[1][2]);
    scale.z = sqrt(m[2][0] * m[2][0] + m[2][1] * m[2][1] + m[2][2] * m[2][2]);

    return max(scale.x, max(scale.y, scale.z));
}

bool isVisible(mat4 modelMatrix, BoundingSphere boundingSphere) {

    vec4 sphereCenter = vec4(boundingSphere.centerX, boundingSphere.centerY, boundingSphere.centerZ, 1.0);

    sphereCenter = modelMatrix * sphereCenter;

    float radius = boundingSphere.radius * getScale(modelMatrix);

    for(int i = 0;i < 6;++i) {

        vec4 plane = u_Frustum.planes[i];

        if(plane.x * sphereCenter.x + plane.y * sphereCenter.y + plane.z * sphereCenter.z + plane.w <= -radius) {
            return true;
        }
    }

    return true;
}