#version 450 core

struct DrawCommand {
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
};

struct BoundingSphere {
    float centerX;
    float centerY;
    float centerZ;
    float radius;
};

// TODO: need camera matrices

layout(local_size_x = 1) in;

layout(std430, binding = 0) readonly buffer MeshCommandBuffer {
    DrawCommand[] meshCommands;
};

layout(std430, binding = 1) writeonly buffer CommandBuffer {
    DrawCommand[] instanceCommands;
};

layout(std430, binding = 2) readonly buffer BoundingSpheres {
    BoundingSphere boundingSpheres[];
};

layout(std430, binding = 3) readonly buffer Matrices {
    mat4 modelMatrices[];
};

layout(std430, binding = 4) readonly buffer MeshIDs {
    int meshIDs[];
};

layout(std140, binding = 5) uniform Frustum {
    mat4 projectionViewMatrix;
    vec4 planes[6];
} u_Frustum;

bool isVisible(mat4 modelMatrix, BoundingSphere boundingSphere);

void main() {

    const uint index = gl_GlobalInvocationID.x;

    const int meshID = meshIDs[index];

    if(isVisible(modelMatrices[index], boundingSpheres[meshID])) {

        DrawCommand meshCommand = meshCommands[meshID];

        DrawCommand command = meshCommand;

        command.instanceCount = 1;
        command.baseInstance = index;

        instanceCommands[index] = command;
    }
}

// Computes signed distance between a point and a plane
// vPlane: Contains plane coefficients (a,b,c,d) where: ax + by + cz = d
// vPoint: Point to be tested against the plane.
float distanceToPlane(vec4 vPlane, vec3 vPoint)
{
    return dot(vec4(vPoint, 1.0), vPlane);
}
 
// Frustum cullling on a sphere. Returns > 0 if visible, <= 0 otherwise
float cullSphere(vec4 vPlanes[6], vec3 vCenter, float fRadius)
{
   float dist01 = min(distanceToPlane(vPlanes[0], vCenter), distanceToPlane(vPlanes[1], vCenter));
   float dist23 = min(distanceToPlane(vPlanes[2], vCenter), distanceToPlane(vPlanes[3], vCenter));
   float dist45 = min(distanceToPlane(vPlanes[4], vCenter), distanceToPlane(vPlanes[5], vCenter));
 
   return min(min(dist01, dist23), dist45) + fRadius;
}

float getScale(mat4 m) {

    vec3 scale;

    scale.x = sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1] + m[0][2] * m[0][2]);
    scale.y = sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1] + m[1][2] * m[1][2]);
    scale.z = sqrt(m[2][0] * m[2][0] + m[2][1] * m[2][1] + m[2][2] * m[2][2]);

    return max(scale.x, max(scale.y, scale.z));
}

bool isVisible(mat4 modelMatrix, BoundingSphere boundingSphere) {

    vec4 sphereCenter = vec4(boundingSphere.centerX, boundingSphere.centerY, boundingSphere.centerZ, 1.0);

    sphereCenter = modelMatrix * sphereCenter;

    float radius = boundingSphere.radius * getScale(modelMatrix);

    // This does not work. I don't know if it has to do with the bounding sphere, or with the frustum calculation
    return true;// cullSphere(u_Frustum.planes, sphereCenter.xyz, radius) > 0;
}