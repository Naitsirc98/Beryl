#version 450 core

struct DrawCommand {
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
};

struct BoundingSphere {
    float centerX;
    float centerY;
    float centerZ;
    float radius;
};

@include "structs/transform.glsl"


layout(local_size_x = 1) in;


layout(std430, binding = 0) readonly buffer MeshCommandBuffer {
    DrawCommand[] u_MeshCommands;
};

layout(std430, binding = 1) writeonly buffer CommandBuffer {
    DrawCommand[] u_InstanceCommands;
};

layout(std430, binding = 2) readonly buffer BoundingSpheres {
    BoundingSphere u_BoundingSpheres[];
};

layout(std430, binding = 3) readonly buffer Transforms {
    Transform u_Transforms[];
};

layout(std430, binding = 4) readonly buffer MeshIndices {
    int u_MeshIndices[];
};

layout(std140, binding = 5) uniform Frustum {
    mat4 projectionViewMatrix;
    vec4 planes[6];
} u_Frustum;

layout(std430, binding = 6) writeonly buffer Debug {
    vec4 debug[];
};



// Computes signed distance between a point and a plane
// vPlane: Contains plane coefficients (a,b,c,d) where: ax + by + cz = d
// vPoint: Point to be tested against the plane.
float distanceToPlane(vec4 vPlane, vec3 vPoint)
{
    return dot(vec4(vPoint, 1.0), vPlane);
}
 
// Frustum cullling on a sphere. Returns > 0 if visible, <= 0 otherwise
float cullSphere(vec4 vPlanes[6], vec3 vCenter, float fRadius)
{
   float dist01 = min(distanceToPlane(vPlanes[0], vCenter), distanceToPlane(vPlanes[1], vCenter));
   float dist23 = min(distanceToPlane(vPlanes[2], vCenter), distanceToPlane(vPlanes[3], vCenter));
   float dist45 = min(distanceToPlane(vPlanes[4], vCenter), distanceToPlane(vPlanes[5], vCenter));
 
   return min(min(dist01, dist23), dist45) + fRadius;
}

float getScale(mat4 m) {

    vec3 scale;

    scale.x = sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1] + m[0][2] * m[0][2]);
    scale.y = sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1] + m[1][2] * m[1][2]);
    scale.z = sqrt(m[2][0] * m[2][0] + m[2][1] * m[2][1] + m[2][2] * m[2][2]);

    return max(scale.x, max(scale.y, scale.z));
}

bool isVisible(mat4 modelMatrix, BoundingSphere boundingSphere) {

    vec4 sphereCenter = vec4(boundingSphere.centerX, boundingSphere.centerY, boundingSphere.centerZ, 1.0);

    sphereCenter = modelMatrix * sphereCenter;

    float radius = boundingSphere.radius * getScale(modelMatrix);

    // debug[gl_GlobalInvocationID.x] = vec4(sphereCenter.xyz, radius);

    // This does not work. I don't know if it has to do with the bounding sphere, or with the frustum calculation
    return cullSphere(u_Frustum.planes, sphereCenter.xyz, radius) > 0;
}

void main() {

    const uint index = gl_GlobalInvocationID.x;

    const int meshIndex = u_MeshIndices[index];

    DrawCommand meshCommand = u_MeshCommands[meshIndex];

    DrawCommand command = meshCommand;

    command.baseInstance = index;

    if(isVisible(u_Transforms[index].modelMatrix, u_BoundingSpheres[meshIndex])) {
        command.instanceCount = 1;
    } else {
        command.instanceCount = 0;
    }

    u_InstanceCommands[index] = command;
}